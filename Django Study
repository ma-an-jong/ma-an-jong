django 시작하기 210708~

virtual environment >> 사용자가 서로 다른 두 환경에서 상호작용 할 수 있도록 도와줌.
                        각 가상환경은 종속성을 유지한다. 
                        가상환경을 이용함으로서 양쪽의 프로젝트의 종속성을 유지하는것이 매우 편리해진다.
                        proj1 = python 2.6, proj2 = python 3.8
                      
                     
django -admin startproject config . >> 현재 디렉토리에서 django를 시작 생성되는 파일은 다음과같다

장고는 MVC패턴에서 views = Templates , controls = views 이다. 따라서 
장고는 MTV패턴이라고 생각하자.


LocalDir
  config
      __init__
      asgi : channels를 이용할때 필요함
      settings : Django 프로젝트의 환경 및 구성을 저장. 웹사이트의 설정이 저장되어있음
      urls : 프로젝트의 url을 저장, url의 규칙을 보고 내부에 일치하는 view를 찾아 1:1 연결
      wsgi : 웹서버와 통신하기 위한 인터페이스
  AppName
      __init__
      admin : 앱의 관리자 사이트 설정
      apps : 앱의 기본 설정을 담음
      models : 모델에 대한 정보를 저장하고 테이블 필드를 제어
      views : 앱에 대한 view를 생성 (Control에 해당)
      tests : test case
      migration : 데이터베이스에서 정보를 얻어와 다른곳으로 전송시켜주는 프로세스
  
  manage: project와 상호작용하는 유틸리티도구
          스크립트와 사이트 관리를 도와줌
          웹서버를 실행해줌
          
         
Page Not Found 404 errors : urls.py에 URL매핑이 없기 때문이다.
HttpResponse : 페이지 요청에 대한 응답을 할 때 이용되는 장고 클래스

def index(request):
  return HttpResponse()
  
  URL을 분리하여 저장 : App관련 파일은 거의 AppName 디렉토리에 있어야하는데 urls.py는 그렇지 않다 따라서 URL이 수정될때 config 디렉터리에 있는 
  urls를 수정해야한다 이것은 프로젝트의 설계에 잘못된것이며 urls.py 를 따로 구성해야한다.
    path('AppName/',include('AppName.urls'))를 통해 AppName으로 시작되는 페이지 요청은 모두 AppName.urls의 URL 매핑을 참고하여 처리하라는 의미이다.
    AppName.urls.py 의 path('create',views.index)이면 최종 URL은 AppName/create/가 된다
unapplied migration(s). >> INSTALLED_APPS에서 데이터베이스를 이용하는 앱들이 필요로 하는 테이블이 생성되지 않았기때문이다.
  python manage.py migrate를 통해서 각 앱들이 사용하는 테이블을 만들어준다.

Django의 ORM(object relational mapping) : 데이터베이스와 객체간의 호환되지 않는 데이터를 매핑해주는 프로그래밍 기법
ORM 덕분에 파이썬은 Query문을 작성하지 않고 DML DDL등을 이용 할 수 있다.

ORM은 DB의 3가지 단점을 제거한다.
  1.개발자마다 작성되는 Query문은 통일성이 깨진다.
  2.개발자가 Query문을 잘못 작성하게 되면 시스템 성능이 저하된다.
  3.데이터베이스를 변경하게 되면 데이터베이스에 의존적인 Query문을 모두 재작성해야한다.
  
  ORM은 테이블을 모델화하여 사용하여 Query문을 자동으로 생성하기 때문에 Query문 작성에 의한 3가지 단점을 모두 제거한다.
  
  
models.py에 모델 작성하기
  class Model(models.Model):
    """
    필드 선언
    """
  Class 생성을 통해 모델을 정의한다. 객체의 필드는 테이블의 속성이 되도록 필드에 변수를 선언하고 각 변수에 맞는 값을 대입해주면 된다.
  models.Model은 이 Model클래스가 장고 모델임을 인식하여 데이터베이스에 저장되어야 할 클래스 임을 알게된다.

    INSTALLED_APP에 작성한 AppName을 등록해야한다.
    
    INSTALLED_APP = [
      """
      'AppName.apps.AppNameConfig'
      """
    ]
    
    apps.py 에 AppNameConfig클래스를 만든다.
    
    from django.apps import AppConfig
    class AppNameConfig(AppConfig):
      name = 'AppName'
    
    INSTALLED_APP에 추가했으면 migrate로 테이블을 생성해줘야한다.
    하지만 모델이 생성되거나 변경되면 테이블 작업 파일이 필요하기 때문에 makemigrations를 먼저 실행한다
    만약 함수가 추가되면 makemigration이나 migration을 할 필요가없다 왜나하면 모델의 속성이 추가되거나 변경된 경우가 아니기 때문이다.
    python manage.py makemigrations 를 통해 장고가 테이블 작업을 수행하기 위한 파일들을 생성해준다. 실제 테이블 생성 명령은 migration이다.
    
    Django shell : python shell 과는 다르게 장고에 필요한 환경들이 자동으로 설정되어 실행된다.
    
    shell을 이용하여 Model데이터 만들기 : Models(field)작성  >> .save() 를 통해 shell에서 작성한 객체를 데이터베이스에 저장해야함.
    모델 데이터에 id라는 기본키를 자동으로 부여한다. 데이터를 생성 할 때 마다 1씩 증가한다.
    데이터베이스에 저장된 내용을 지우고싶으면 .delete() 함수를 이용한다.
    
    A 모델과 B모델을 연결하려면 (B가 A의 기본키를 참조) ForeignKey로 A 모델과 B모델을 연결한다.\
    이렇게 연결된 모델로 데이터를 조회하려면 A.B_set과 같은 방법으로 데이터를 조회할수있다.
    
    A한개와 연결된 B 여러개를 조회하려면  A.B_set.all()을 통해 조회가 가능하다. 하지만 반대로
    B에 대응하는 A_set을 조회하는것은 불가능하다. 왜냐하면 1개의 B는 1개의 A에 연결되어 있기 때문에 A전체를 조회하는것은 불가능하다.
    
    
    Django admin  -Model관리 가능 
    
    admin을 사용하기 위해서는 슈퍼 유저(운영자 계정)를 생성해야한다.
    
    python manage.py createsuperuser를 통해서 슈퍼 유저를 생성한다.
    
    admin에 models를 import하여 데이터 저장 수정 삭제등 작업을 Admin을 통해 할 수 있다.
    """
    from .models import A
    
    admin.site.register(A)
    """
    Admin화면에서 A모델을 직관적으로 관리 할 수 있다.
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
